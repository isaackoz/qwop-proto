syntax = "proto3";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "buf/validate/validate.proto";

package chat.v1;

option go_package = "./v1";

service ChatService {
  rpc Chat(ChatRequest) returns (stream ChatResponse);
  rpc GetConvo(GetConvoRequest) returns (GetConvoResponse);
  // Gets 50 conversations starting from the cursor position. The order is deterministic between pages unless conversations are added/removed.
  rpc GetHistory(GetHistoryRequest) returns (GetHistoryResponse);
  rpc GetRecentHistory(GetRecentHistoryRequest) returns (GetRecentHistoryResponse);
  rpc GetConvoFolders(GetConvoFoldersRequest) returns (GetConvoFoldersResponse);
  rpc CreateFolder(CreateFolderRequest) returns (CreateFolderResponse);
  rpc DeleteFolder(DeleteFolderRequest) returns (DeleteFolderResponse);
  rpc RenameFolder(RenameFolderRequest) returns (RenameFolderResponse);
  rpc DeleteConvo(DeleteConvoRequest) returns (DeleteConvoResponse);
  rpc RenameConvo(RenameConvoRequest) returns (RenameConvoResponse);
  rpc MoveConvoToFolder(MoveConvoToFolderRequest) returns (MoveConvoToFolderResponse);
  rpc MoveFolderPosition(MoveFolderPositionRequest) returns (MoveFolderPositionResponse);
  rpc GetFolderInstructions(GetFolderInstructionsRequest) returns (GetFolderInstructionsResponse);
  rpc UpdateFolderInstructions(UpdateFolderInstructionsRequest) returns (UpdateFolderInstructionsResponse);
  rpc CreatePersona(CreatePersonaRequest) returns (CreatePersonaResponse);
  rpc DeletePersona(DeletePersonaRequest) returns (DeletePersonaResponse);
  rpc UpdatePersona(UpdatePersonaRequest) returns (UpdatePersonaResponse);
  rpc SetPersonaAsDefault(SetPersonaAsDefaultRequest) returns (SetPersonaAsDefaultResponse);
  rpc GetPersonasList(GetPersonasListRequest) returns (GetPersonasListResponse);
  rpc GetPersonaDetails(GetPersonaDetailsRequest) returns (GetPersonaDetailsResponse);
  rpc GetDefaultPromptOptions(GetDefaultPromptOptionsRequest) returns (GetDefaultPromptOptionsResponse);
  // Cancel an agent for the specified agent
  rpc CancelAgent(CancelAgentRequest) returns (CancelAgentResponse);

  rpc CreateRating(CreateRatingRequest) returns (CreateRatingResponse);

  rpc BranchConversation(BranchConversationRequest) returns (BranchConversationResponse);
}

message BranchConversationRequest {
  string currentConvoId = 1 [(buf.validate.field).string.uuid = true];
  string lastMessageId = 2 [(buf.validate.field).string.uuid = true];
}

message BranchConversationResponse {
  string newConvoId = 1;
}

message CreateRatingRequest {
  bool rating_value = 1;
  optional string feedback = 2 [(buf.validate.field).string.max_len = 1000];
  string message_id = 3 [(buf.validate.field).string.uuid = true];
  string version_id = 4 [(buf.validate.field).string.uuid = true];
}

message CreateRatingResponse {}

message CancelAgentRequest {
  // the agent id of the running agent to cancel
  string agent_id = 1 [(buf.validate.field).string.uuid = true];
}

message CancelAgentResponse {}

enum ChatModel {
  CHAT_MODEL_UNSPECIFIED = 0;
  CHAT_MODEL_GEMINI = 1;
  CHAT_MODEL_GROK = 2;
  CHAT_MODEL_CLAUDE = 3;
  CHAT_MODEL_OPENAI = 4;
  CHAT_MODEL_CUSTOM = 5;
}

message PromptOptions {
  // the default or last used persona
  optional string persona_id = 1;
  // the default or last used model
  optional ChatModel model = 2;
  bool reasoning = 3;
}

message GetDefaultPromptOptionsRequest {}

message GetDefaultPromptOptionsResponse {
  PromptOptions options = 1;
}

message GetPersonasListRequest {}

message GetPersonasListResponse {
  repeated Persona personas = 1;
}

message GetPersonaDetailsRequest {
  string id = 1 [(buf.validate.field).string.uuid = true];
}

message GetPersonaDetailsResponse {
  Persona persona = 1;
}

message Persona {
  string id = 1;
  string name = 2;
  string persona = 3;
  bool is_default = 4;
}

message DeletePersonaRequest {
  string id = 1 [(buf.validate.field).string.uuid = true];
}
message DeletePersonaResponse {}

message UpdatePersonaRequest {
  string id = 1 [(buf.validate.field).string.uuid = true];
  string name = 2 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 100
  ];
  string persona = 3 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 5000
  ];
}

message UpdatePersonaResponse {}

message SetPersonaAsDefaultRequest {
  string id = 1 [(buf.validate.field).string.uuid = true];
}

message SetPersonaAsDefaultResponse {}

message CreatePersonaRequest {
  string name = 1 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 100
  ];
  string persona = 2 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 5000
  ];
}

message CreatePersonaResponse {
  string id = 1;
}

message GetFolderInstructionsRequest {
  string folder_id = 1 [(buf.validate.field).string.uuid = true];
}

message GetFolderInstructionsResponse {
  string instructions = 1;
}

message UpdateFolderInstructionsRequest {
  string folder_id = 1 [(buf.validate.field).string.uuid = true];
  string instructions = 2 [
    (buf.validate.field).string.min_len = 0,
    (buf.validate.field).string.max_len = 5000
  ];
}

message UpdateFolderInstructionsResponse {}

message RenameFolderRequest {
  string id = 1 [(buf.validate.field).string.uuid = true];
  string new_name = 2 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 100
  ];
}

message RenameFolderResponse {
  ConvoFolder folder = 1;
}

message GetRecentHistoryRequest {}

message GetRecentHistoryResponse {
  repeated ConvoHistory conversations = 1;
}

message MoveFolderPositionRequest {
  string a_folder_id = 1 [(buf.validate.field).string.uuid = true];
  string b_folder_id = 2 [(buf.validate.field).string.uuid = true];
}

message MoveFolderPositionResponse {}

message DeleteConvoRequest {
  string id = 1;
}

message DeleteConvoResponse {}

message RenameConvoRequest {
  string id = 1;
  string new_title = 2;
}

message RenameConvoResponse {}

message MoveConvoToFolderRequest {
  string convo_id = 1 [(buf.validate.field).string.uuid = true];
  string folder_id = 2 [(buf.validate.field).string.uuid = true];
}

message MoveConvoToFolderResponse {}

message CreateFolderRequest {
  string name = 1 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 100 
  ];
}
message CreateFolderResponse {
  ConvoFolder folder = 1;
}

message DeleteFolderRequest {
  string id = 1 [(buf.validate.field).string.uuid = true];
  bool delete_children = 2;
}

message DeleteFolderResponse {}

message GetConvoFoldersRequest {}

message GetConvoFoldersResponse {
  repeated ConvoFolder folders = 1;
}

message ConvoFolder {
  string id = 1;
  string name = 2;
  int32 pos = 3;
}

// Returns 50 conversations starting from the cursor position
message GetHistoryRequest {
  // starting at 0 
  int32 cursor = 1;
  optional string folder_id = 2 [(buf.validate.field).string.uuid = true];
}

message ConvoHistory {
  string id = 1;
  optional string title = 2;
  google.protobuf.Timestamp updated_at = 3;
  // rfc 3339
  google.protobuf.Timestamp created_at = 4;
  optional string folder_id = 5;
}

message GetHistoryResponse {
  repeated ConvoHistory conversations = 1;
}

message GetConvoRequest {
  string id = 1 [(buf.validate.field).string.uuid = true];
}

message GetConvoResponse {
  Conversation conversation = 1;
}

message Conversation {
  string id = 1;
  optional string title = 2;
  optional google.protobuf.Timestamp context_last_updated = 3;
  optional string context = 7;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
  optional string folder_id = 8;
  optional string persona_id = 9;
  repeated Message messages = 6;
}

enum MessageRole {
  MESSAGE_ROLE_UNSPECIFIED = 0;
  MESSAGE_ROLE_USER = 1; // user message
  MESSAGE_ROLE_ASSISTANT = 2; // assistant message
}

message MessageVersion {
  string id = 1;
  int32 version_number = 2;
  google.protobuf.Timestamp created_at = 3;
  repeated MessagePart parts = 4;
  bool pending = 5;
  optional string error = 6;
  bool cancelled = 7;
}

message Message {
  string id = 1;
  google.protobuf.Timestamp created_at = 2;
  google.protobuf.Timestamp updated_at = 3;
  MessageRole role = 4;
  repeated MessageVersion versions = 5;
}


// Parts making up a message.
// Parts are what we store in the database and contain all the data to render each part.
// They are tied 1-1 with their corresponding service below (i.e. text part with text service).
// The service is a stream of updates that modify the part in some way. The end result of a service 
// should be a complete part. In other words, the sum of all the deltas from a service should equal
// the final part stored in the message. 
//
// The order of the parts is important as it defines how the message is rendered. The only exception is the ToolCallsPart, which doesn't get rendered directly.
// If you want to render tool calls, send a thinking part in tandem.
//
message MessagePart {
  oneof part {
    UserPart user = 1;
    AssistantPart assistant = 2;
    ProcessingPart processing = 3;
    // For backend only (ignore in the frontend)
    ToolInvocationsPart tool_invocations = 4;
    // For backend only (ignore in the frontend)
    ToolResultsPart tool_results = 5;
    ErrorPart error = 6;
  }
}

message ErrorPart {
  string msg = 1;
  optional string code = 2;
}

// Tool calls consist of two parts:
// The AI's tool call intention and the tool call result.
// The AI Tool call intention has a role of assistant and contains no content. It contains tool_calls which is an array of
// tools to call. Each item has an id (unique identifier for the tool call), a type (usually always "function"), and a field called "function"
// which contains a name (the functions name in our system) and arguments (a stringified json text of the args to pass).
//
// It us up to us, the dev, to call this function. The second part is the tool call result. The tool call result has a role of "tool".
// It has a field called "tool_call_id" which is mapped to the tool call intention above. Since there can be multiple tool calls from above, 
// we map each result to it's own message and map them to the tool_call_id. Lastly, the result also contains a field called "content" which is just a string of the result.
//
// ### If a tool call result is missing, it will not be included in the message to the LLM.
// The invocation and results are decoupled by design to allow for flexibility in handling multiple tool calls asynchronously.

message ToolInvocationsPart {
  repeated ToolCallInvocation invocations = 1;
}

message ToolResultsPart {
  repeated ToolCallResult results = 1;
}

message ToolCallInvocation {
  string id = 1;
  string type = 2;
  ToolCallInvocationFunction function = 3;
}

message ToolCallInvocationFunction {
  // the name of the function in our backend
  string name = 1;
  // usually a json stringified string of the arguments to pass to the function
  string args = 2;
}

message ToolCallResult {
  // The id of the tool call invocation. (This is not the function name)
  string id = 1;
  string name = 2;
  // The tool call result. Can be text or json stringified string. Should ideally be converted to natural language as something the LLM would understand.
  // For example, instead of {"name": john, "age": 23} it might be better to do "Name=John, Age 23". This requires testing per function as the LLM might understand 
  // the output better on a per-tool basis. Some tool results might be better understood in JSON while others with natural language or others in CSV format. It all depends.
  // But regardless, the end result must be a string.
  string content = 3;
  // If not nil/"", will indicate the tool call failed with this error. The error message will be used as the content instead, informing the LLM of the failure.
  optional string error = 4;
}


// A part representing text/markdown
message UserPart {
  // If a user part is being accessed during streaming, content will be a delta of the full message. Otherwise, it will be the full message.
  string content = 1;
}

// Same as UserPart right now.
message AssistantPart {
  oneof part {
    AssistantPartText text = 1;
  }
}

message AssistantPartText {
  string content = 1;
}


message ProcessingPartStep {
  string id = 1;
  // i.e. "Finding sources..." or "Thinking..."
  string summary = 2;
  // more detailed info, i.e. sources found, reasoning steps, etc.
  repeated string detail = 3;
}

message ProcessingPart {
  // during streaming, summary will overwrite the previous summary. Otherwise it is the final summary. (this is never a delta)
  string summary = 1;
  // the steps taken during the thinking/processing process. during streaming these are deltas that must be merged. otherwise they are the final steps.
  repeated ProcessingPartStep steps = 2;
}

message ChatOptions {
  // include tickers automatically inferred from chat or explicitly?
  bool ticker_auto = 1;
  repeated string ticker_ids = 2;
  // should we include trade journal automatically or explicitly?
  bool journal_auto = 3;
  repeated string journal_ids = 4;
  // should we fetch fresh data or re-use old calculations?
  bool fresh_data = 5;
  // shoud we automatically infer indicators from the query or explicitly set?
  bool indicator_auto = 6;
  // If set, use this persona for the chat. If it isn't it will use the default or last used persona.
  optional string persona_id = 7 [(buf.validate.field).string.uuid = true];
  // If set, will create the new convo in this folder and also include that folders instructions
  optional string folder_id = 8 [(buf.validate.field).string.uuid = true];
}

message ChatMeta {
  string timezone = 1;
  string locale = 2;
}

message ChatRequest {
  // The information this can either be a new chat/continuing, editing or retrying a message
  oneof info {
    option (buf.validate.oneof).required = true;
    ChatInfo chat = 1;
    EditInfo edit = 2;
    RetryInfo retry = 3;
  }
  ChatMeta meta = 6 [(buf.validate.field).required = true];
  ChatOptions options = 7 [(buf.validate.field).required = true];
}
// For retrying a (bot) message
message RetryInfo {
  string convo_id = 1 [(buf.validate.field).string.uuid = true];
  string message_id = 2 [(buf.validate.field).string.uuid = true];
  string version_id = 3 [(buf.validate.field).string.uuid = true];
}
// For editing an existing (user) message
message EditInfo {
  string convo_id = 1 [(buf.validate.field).string.uuid = true];
  // the message to edit. This must be a user role message.
  string message_id = 2 [(buf.validate.field).string.uuid = true];
  string version_id = 3 [(buf.validate.field).string.uuid = true];
  string new_query = 4;
}
// For a new convo or continuing a conversation. Appends the message at the end of the convo.
message ChatInfo {
  string query = 1;
  // if provided, the message will be added to a convo. If not, it will create a new convo
  // and return the new convo id in the NewConvoEvent
  optional string convo_id = 2 [(buf.validate.field).string.uuid = true];

}

message ChatResponse {
  oneof message {
    ServiceEvent service_event = 1;
    NewConvoEvent new_convo_event = 2;
    ErrorEvent error_event = 3;
    ConvoUpdateEvent convo_update_event = 4;
    MessageMetaDataEvent message_meta_data_event = 5;
  }
}

message MessageMetaDataEvent {
  string message_id = 1;
  string version_id = 2;
  string agent_id = 3;
}

// After a new convo is created and the summary is created,
// we want to optimistically update the history in the sidebar with this data
message NewConvoEvent {
  string id = 1;
  string title = 2;
  optional string folder_id = 3; 
}

// Send an update when a convo is updated, i.e. renamed
message ConvoUpdateEvent {
  string id = 1;
  optional string title = 2;
  optional string folder_id = 3; 
}

message ErrorEvent {
  string message = 1;
  optional string code = 2;
}



enum ServiceStatus {
  SERVICE_STATUS_UNSPECIFIED = 0;
  SERVICE_STATUS_STARTED = 1;
  SERVICE_STATUS_COMPLETED = 2;
  SERVICE_STATUS_ERROR = 3;
  SERVICE_STATUS_DATA = 4;
}

// The server decides ultimitaly which service to use. Right now we just have 
// chat, but in the future we will have more
message ServiceEvent {
  string id = 1;
  ServiceStatus status = 2;
  // code is an optional event code. i.e. for an error it could be "wrong_model" or something
  optional string code = 3;
  oneof data {
    UserService user_service = 4;
    AssistantService assistant_service = 5;
    ProcessingService processing_service = 6;
    ErrorService error_service = 7;
  }
}

message ErrorService {
  string msg = 1;
  optional string code = 2;
}

message UserService {
  optional string delta = 1;
}


message AssistantService {
  oneof part {
    AssistantServiceText text = 1;
  }
}


message AssistantServiceText {
  string delta = 1;
}

// The ProcessingService is used for either reasoning or to indicate progress on a multi-step task.
message ProcessingService {
  // Step id is unique to each step. It can be used to identify which step is being updated.
  // If step ID is not set, the other fields will be ignored (i.e. for a status update)
  optional string step_id = 1;
  // A brief summary of what this step is doing
  optional string step_summary = 2;
  // A more detailed update on the step's progress
  optional string step_update = 3;
  // The summary of the thinking process. For example, this could be 
  // "Thinking..." or "Researching..." or "Thought for 24 seconds"
  optional string summary = 6;
}